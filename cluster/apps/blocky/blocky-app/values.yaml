# Default values for blocky.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: ghcr.io/0xerr0r/blocky
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  main:
    enabled: true
    type: ClusterIP
    port: 4000
  dns:
    enabled: true
    type: LoadBalancer
    loadBalancerIP: 192.168.0.241
    port: 53

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 100m
  #   memory: 128Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

nodeSelector: {}

affinity:
  nodeAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
      nodeSelectorTerms:
      - matchExpressions:
        - key: location
          operator: In
          values:
          - lan

tolerations:
  - key: pi-node
    operator: Exists
    effect: NoSchedule

metrics:
  # -- Enable and configure a Prometheus serviceMonitor for the chart under this key.
  # @default -- See values.yaml
  enabled: true
  serviceMonitor:
    # -- Interval at which Prometheus should scrape metrics
    interval: 30s
    # -- Timeout after which the scrape is ended
    scrapeTimeout: 10s
    # -- Additional labels for the Kubernetes `ServiceMonitor` object
    labels: {}
    # -- The Kubernetes `Endpoints` label to use as the Prometheus job name
    jobLabel: ""
    # -- TargetLabels transfers labels from the Kubernetes `Service`` onto the created metrics.
    targetLabels: []
    # -- PodTargetLabels transfers labels on the Kubernetes `Pod`` onto the created metrics.
    podTargetLabels: []
  # -- Enable and configure Prometheus Rules for the chart under this key.
  # @default -- See values.yaml
  prometheusRule:
    enabled: true
    labels: {}
    # -- Configure additionial rules for the chart under this key.
    # @default -- See prometheusrules.yaml
    rules: []
      # - alert: BlockyDisabled
      #   annotations:
      #     description: Blocky's ad blocking has been disabled for 15min.
      #       Please re-enable protection.
      #     summary: Blocky is disabled.
      #   expr: |
      #     blocky_blocking_enabled == 0
      #   for: 15m
      #   labels:
      #     severity: critical

config: |
  upstream:
    default:
      - 192.168.0.1

  bootstrapDns:
  - tcp+udp:192.168.0.1

  clientLookup:
    upstream: 192.168.0.1
    singleNameOrder:
    - 2
    - 1

  ports:
    dns: 53
    http: 4000

  prometheus:
    enable: true
    path: /metrics

  # optional: use black and white lists to block queries (for example ads, trackers, adult pages etc.)
  blocking:
    # definition of blacklist groups. Can be external link (http/https) or local file
    blackLists:
      ads:
        - https://s3.amazonaws.com/lists.disconnect.me/simple_ad.txt
        - https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts
        - http://sysctl.org/cameleon/hosts
        - https://s3.amazonaws.com/lists.disconnect.me/simple_tracking.txt
        - |
          # inline definition with YAML literal block scalar style
          someadsdomain.com
          *.example.com        
      special:
        - https://raw.githubusercontent.com/StevenBlack/hosts/master/alternates/fakenews/hosts
    # definition of whitelist groups. Attention: if the same group has black and whitelists, whitelists will be used to disable particular blacklist entries. If a group has only whitelist entries -> this means only domains from this list are allowed, all other domains will be blocked
    whiteLists:
      ads:
        - whitelist.txt
        - |
          # inline definition with YAML literal block scalar style
          # hosts format
          whitelistdomain.com
          # this is a regex
          /^banners?[_.-]/        
    # definition: which groups should be applied for which client
    clientGroupsBlock:
      # default will be used, if no special definition for a client name exists
      default:
        - ads
        - special
      # use client name (with wildcard support: * - sequence of any characters, [0-9] - range)
      # or single ip address / client subnet as CIDR notation
      # laptop*:
      #   - ads
      # 192.168.178.1/24:
      #   - special
    # which response will be sent, if query is blocked:
    # zeroIp: 0.0.0.0 will be returned (default)
    # nxDomain: return NXDOMAIN as return code
    # comma separated list of destination IP addresses (for example: 192.100.100.15, 2001:0db8:85a3:08d3:1319:8a2e:0370:7344). Should contain ipv4 and ipv6 to cover all query types. Useful with running web server on this address to display the "blocked" page.
    blockType: zeroIp
    # optional: TTL for answers to blocked domains
    # default: 6h
    blockTTL: 1m
    # optional: Configure how lists, AKA sources, are loaded
    loading:
      # optional: list refresh period in duration format.
      # Set to a value <= 0 to disable.
      # default: 4h
      refreshPeriod: 24h
      # optional: Applies only to lists that are downloaded (HTTP URLs).
      downloads:
        # optional: timeout for list download (each url). Use large values for big lists or slow internet connections
        # default: 5s
        timeout: 60s
        # optional: Maximum download attempts
        # default: 3
        attempts: 5
        # optional: Time between the download attempts
        # default: 500ms
        cooldown: 10s
      # optional: Maximum number of lists to process in parallel.
      # default: 4
      concurrency: 16
      # Configure startup behavior.
      # accepted: blocking, failOnError, fast
      # default: blocking
      strategy: failOnError
      # Number of errors allowed in a list before it is considered invalid.
      # A value of -1 disables the limit.
      # default: 5
      maxErrorsPerSource: 5

